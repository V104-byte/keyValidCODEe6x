
local toggleKey = Enum.KeyCode.C
local orbitRadius = 40
local orbitRadius2 = 1

local orbitSpeed = 27
local orbitSpeedY = 27
local movementSpeed = 32
local overrideAutoFarmCenter = nil

-- TextBox para OrbitSpeedY
local UsingClone = false


-- Temas:
-- 1 = Paid Infinity (amarelo desbotado)
-- 2 = Classic Infinity (azul)
-- 3 = Amarelo forte
_G.InfinityTheme = 1 -- Altere para 1, 2 ou 3 para mudar o tema


local Players = game:GetService("Players")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Cria o ScreenGui se ainda não existir
local gui = playerGui:FindFirstChild("ThemeToggleGui") or Instance.new("ScreenGui")
gui.Name = "ThemeToggleGui"
gui.ResetOnSpawn = false
gui.Parent = playerGui

-- Cria o botão
local button = Instance.new("TextButton")
button.Name = "ThemeToggleButton"
button.Size = UDim2.new(0, 120, 0, 40)
button.Position = UDim2.new(0, 10, 0, 10)
button.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
button.TextColor3 = Color3.new(1, 1, 1)
button.TextSize = 18
button.Font = Enum.Font.GothamBold
button.Text = "Tema: 1"
button.Parent = gui

-- Inicializa a variável global
_G.InfinityTheme = _G.InfinityTheme or 1

-- Atualiza o botão e incrementa o tema
local function cycleTheme()
    _G.InfinityTheme += 1
    if _G.InfinityTheme > 3 then
        _G.InfinityTheme = 1
    end
    button.Text = "Tema: " .. tostring(_G.InfinityTheme)
end

-- Conecta clique
button.MouseButton1Click:Connect(cycleTheme)


-- 15 radius para ball speed 0 ou mais
-- 25 radius para ball speed 400 ou mais
-- 45 radius para ball speed 900 ou mais
-- 65 radius para ball speed 2500 ou mais

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local lp = Players.LocalPlayer
local character = lp.Character or lp.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

local segments = 150
local color = Color3.fromRGB(79, 108, 224)
local partSize = Vector3.new(0.5, 0.5, 0.5)
-- Cria GUI
local StarterGui = game:GetService("StarterGui")
local PlayerGui = Players.LocalPlayer:WaitForChild("PlayerGui")

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "OrbitSpeedGui"
screenGui.ResetOnSpawn = false
screenGui.Parent = PlayerGui


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")


local emitterPart = nil
local heartbeatConnection = nil
local function createParticleEmitter(parent)
    if not parent then
        warn("createParticleEmitter: parent é nil")
        return nil
    end

    local existing = parent:FindFirstChild("PurpleSmoke")
    if existing then
        existing.Enabled = true
        return existing
    end

    local particleEmitter = Instance.new("ParticleEmitter")
    particleEmitter.Name = "PurpleSmoke"
    particleEmitter.Texture = "rbxassetid://258128463" -- textura de fumaça
if  _G.InfinityTheme == 2 then

    particleEmitter.Color = ColorSequence.new(Color3.fromRGB(0, 0, 255)) -- roxo
    else
particleEmitter.Color = ColorSequence.new(Color3.fromRGB(224, 220, 105)) -- roxo
    end
    particleEmitter.LightEmission = 3
    particleEmitter.Rate = 25
    particleEmitter.Lifetime = NumberRange.new(1, 3)
    particleEmitter.Speed = NumberRange.new(1, 2)
    particleEmitter.Rotation = NumberRange.new(0, 360)
    particleEmitter.RotSpeed = NumberRange.new(-30, 30)
    particleEmitter.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 1),
        NumberSequenceKeypoint.new(1, 3)
    })
    particleEmitter.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0.6),
        NumberSequenceKeypoint.new(1, 1)
    })
    particleEmitter.EmissionDirection = Enum.NormalId.Top
    particleEmitter.LockedToPart = true
    particleEmitter.Enabled = true
    particleEmitter.Parent = parent

    return particleEmitter
end

local function createParticles(targetHRP)
    if not targetHRP then
        warn("createParticles: targetHRP é nil")
        return
    end

    -- Cria o emitter no HRP
    createParticleEmitter(targetHRP)

    -- Cria ou reutiliza part invisível abaixo do HRP
    if not emitterPart or not emitterPart.Parent then
        emitterPart = targetHRP.Parent:FindFirstChild("ParticleEmitterPartBelow")
        if not emitterPart then
            emitterPart = Instance.new("Part")
            emitterPart.Name = "ParticleEmitterPartBelow"
            emitterPart.Size = Vector3.new(1, 1, 1)
            emitterPart.Transparency = 0.5 -- Deixe 0.5 para depuração, depois pode voltar para 1
            emitterPart.Anchored = false
            emitterPart.CanCollide = false
            emitterPart.Massless = true
            emitterPart.Parent = targetHRP.Parent
        end
        createParticleEmitter(emitterPart)
    end

    -- Atualiza posição do part a cada frame
    if not heartbeatConnection then
        heartbeatConnection = RunService.Heartbeat:Connect(function()
            if targetHRP.Parent and emitterPart and emitterPart.Parent then
                emitterPart.CFrame = targetHRP.CFrame * CFrame.new(0, -1.5, 0)
            else
                if heartbeatConnection then
                    heartbeatConnection:Disconnect()
                    heartbeatConnection = nil
                end
            end
        end)
    end
end
local SoundService = game:GetService("SoundService")

-- Função para criar e tocar o som
local function createSound()
    local sound = Instance.new("Sound")
    sound.SoundId = "rbxassetid://7204949322"
    sound.Parent = SoundService
    sound.Volume = 0.6
    return sound
end

local function playMySound()
    local sound = createSound()
    sound:Play()
    sound.Ended:Connect(function()
        sound:Destroy()
    end)
end



local SoundService = game:GetService("SoundService")

local infinitySound = nil
local shouldLoopInfinitySFX = false

function playInfinitySFX()
    if infinitySound and infinitySound.IsPlaying then return end

    shouldLoopInfinitySFX = true

    infinitySound = Instance.new("Sound")
    infinitySound.SoundId = "rbxassetid://1677094219"
    infinitySound.Volume = 0.8
    infinitySound.Looped = false
    infinitySound.Parent = SoundService
    infinitySound:Play()

    -- Repetir quando acabar, se permitido
    infinitySound.Ended:Connect(function()
        if shouldLoopInfinitySFX and infinitySound then
            infinitySound:Play()
        end
    end)
end

function stopInfinitySFX()
    shouldLoopInfinitySFX = false

    if infinitySound then
        infinitySound:Stop()
        infinitySound:Destroy()
        infinitySound = nil
    end
end





local function removeParticles()
    -- Remove emitter do HRP
    if hrp then
        local pe1 = hrp:FindFirstChild("PurpleSmoke")
        if pe1 then
            pe1.Enabled = false
            pe1:Destroy()
        end
    end

    -- Remove emitter e part abaixo
    if emitterPart then
        local pe2 = emitterPart:FindFirstChild("PurpleSmoke")
        if pe2 then
            pe2.Enabled = false
            pe2:Destroy()
        end
        emitterPart:Destroy()
        emitterPart = nil
    end

    -- Desconecta heartbeat
    if heartbeatConnection then
        heartbeatConnection:Disconnect()
        heartbeatConnection = nil
    end
end


-- Para usar, chame:
-- createParticles() -- para criar e ativar os dois emitters
-- removeParticles() -- para remover e parar os emitters

local loopingTrack = nil





local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")


function CIRCLEEFFECT(basePart)
    local segments = 400

    local color
    local transparency

    -- Seleciona cor e transparência com base no tema
    if _G.InfinityTheme == 1 then
        color = Color3.fromRGB(224, 220, 120)
        transparency = 0
    elseif _G.InfinityTheme == 2 then
        color = Color3.fromRGB(75, 93, 243)
        transparency = 0.5
    elseif _G.InfinityTheme == 3 then
        color = Color3.fromRGB(224, 220, 92)
        transparency = 0.5
    else
        color = Color3.fromRGB(255, 255, 255)
        transparency = 0.5
    end

    local folder = Instance.new("Folder", workspace)
    folder.Name = "CircleParts_" .. tostring(math.random(100000, 999999))

    local parts = {}

    for i = 1, segments do
        local part = Instance.new("Part")
        part.Anchored = true
        part.CanCollide = false
        part.Shape = Enum.PartType.Ball
        part.Color = color
        part.Material = Enum.Material.Neon
        part.Transparency = transparency
        part.Size = Vector3.new(1, 0.5, 1) -- começa em tamanho cheio (X=1, Y=0.5, Z=1)
        part.Parent = folder
        parts[i] = part
    end

    local radius = 0
    local maxRadius = 16
    local minSpeed = 0.01
    local maxSpeed = 0.5
    local fadingOut = false

    local connection
    connection = RunService.RenderStepped:Connect(function()
        if not basePart or not basePart.Parent then
            connection:Disconnect()
            folder:Destroy()
            return
        end

        local pos = basePart.Position

        -- Escala do tamanho com base no crescimento do raio
        local scaleAlpha = math.clamp(radius / maxRadius, 0, 1)
local sizeX = 1.5 - 1.1 * scaleAlpha  -- de 1.5 até 0.4

        local newSize = Vector3.new(sizeX, sizeX, sizeX)

        for i, part in ipairs(parts) do
            local angle = math.rad((i / segments) * 360)
            local x = math.cos(angle) * radius
            local z = math.sin(angle) * radius
            part.Position = Vector3.new(pos.X + x, pos.Y, pos.Z + z)
            part.Size = newSize
        end

        if not fadingOut then
            -- Crescimento do raio com desaceleração
            local alpha = radius / maxRadius
            local speed
            if alpha < 0.5 then
                speed = maxSpeed
            else
                local t = (alpha - 0.5) * 2
                speed = maxSpeed - (maxSpeed - minSpeed) * math.clamp(t, 0, 1)
            end

            radius = radius + speed

            if radius >= maxRadius - 1.5 then
                fadingOut = true

                task.spawn(function()
                    for t = 0.7, 1.0, 0.03 do
                        for _, part in ipairs(parts) do
                            part.Transparency = t
                        end
                    end

                    task.wait(0.05)
                    connection:Disconnect()
                    folder:Destroy()
                end)
            end
        end
    end)
end



local function copyAnimationsFromOriginalToClone(original, clone)
    local originalAnimate = original:FindFirstChild("Animate")
    if originalAnimate then
        local cloneAnimate = originalAnimate:Clone()
        cloneAnimate.Parent = clone
    else
        -- Se tiver Animator e AnimationTracks personalizados
        local origHumanoid = original:FindFirstChildOfClass("Humanoid")
        local cloneHumanoid = clone:FindFirstChildOfClass("Humanoid")
        if origHumanoid and cloneHumanoid then
            local origAnimator = origHumanoid:FindFirstChildOfClass("Animator")
            if origAnimator then
                local cloneAnimator = Instance.new("Animator")
                cloneAnimator.Parent = cloneHumanoid
                -- Não é possível copiar AnimationTracks diretamente, apenas reiniciar com os mesmos AnimationIds
                for _, track in ipairs(origAnimator:GetPlayingAnimationTracks()) do
                    local anim = Instance.new("Animation")
                    anim.AnimationId = track.Animation.AnimationId
                    local newTrack = cloneAnimator:LoadAnimation(anim)
                    newTrack:Play()
                end
            end
        end
    end
end

 
local RunService = game:GetService("RunService")

local lastCircleConnection = nil
local lastCircleFolder = nil

function ALTERNATINGCIRCLE(basePart)
    -- Limpa o último efeito se existir
    if lastCircleConnection then lastCircleConnection:Disconnect() end
    if lastCircleFolder and lastCircleFolder.Parent then lastCircleFolder:Destroy() end

    local segments = 70
    local partSize = Vector3.new(0.5, 0.5, 0.5)
    local color = Color3.fromRGB(255, 0, 0)

    local folder = Instance.new("Folder", workspace)
    folder.Name = "AlternatingCircle_" .. tostring(math.random(100000, 999999))

    local parts = {}
    for i = 1, segments do
        local part = Instance.new("Part")
        part.Anchored = true
        part.CanCollide = false
        part.Size = partSize
        part.Shape = Enum.PartType.Ball
        part.Color = color
        part.Material = Enum.Material.Neon
     part.Transparency = UsingClone and 1 or 1
      --part.Transparency = 1
        part.Parent = folder
        parts[i] = part
    end

    local radius = orbitRadius


    -- Salva referências para limpar depois
    lastCircleFolder = folder
    lastCircleConnection = RunService.Heartbeat:Connect(function()
        if not basePart or not basePart.Parent then
            lastCircleConnection:Disconnect()
            folder:Destroy()
            return
        end

        -- Alterna entre 30 e 35
        radius = orbitRadius
        local pos = basePart.Position

        for i = 1, segments do
            local angle = math.rad((i / segments) * 360)
            local x = math.cos(angle) * radius
            local z = math.sin(angle) * radius
            parts[i].Position = Vector3.new(pos.X + x, pos.Y, pos.Z + z)
        end
    end)
end

local RunService = game:GetService("RunService")

function PolygonLoop()
    -- Criação do folder
    local folder = Instance.new("Folder", workspace)
    folder.Name = "PolygonLoop_" .. tostring(math.random(100000, 999999))

    local segments = 70
    local partSize = Vector3.new(0.5, .5, 0.5)
    local color = Color3.fromRGB(20, 240, 20)
    local parts = {}

    for i = 1, segments do
        local part = Instance.new("Part")
        part.Anchored = true
        part.CanCollide = false
        part.Size = partSize
        part.Shape = Enum.PartType.Ball
        part.Color = color
        part.Material = Enum.Material.Neon
        part.Transparency = 0
        part.Parent = folder
        parts[i] = part
    end

    -- Pontos do polígono
    local points = {
        Vector3.new(-137.3, 27.2, -143.9),
        Vector3.new(-209, 27.2, -214.9),
        Vector3.new(-356, 27.2, -215),
        Vector3.new(-428.5, 27.2, -142.8),
        Vector3.new(-428, 27.2, 4.7),
        Vector3.new(-356.1, 27.2, 76.9),
        Vector3.new(-209, 27.2, 76.9),
        Vector3.new(-136.7, 27.3, 4.0),
    }

    local totalEdges = #points
    local segmentsPerEdge = math.floor(segments / totalEdges)
    local remainder = segments % totalEdges

    -- Armazena as partes globais para verificação de distância
    _G.PolygonLoopParts = parts

    RunService.Heartbeat:Connect(function()
        local partIndex = 1
        for i = 1, totalEdges do
            local startPoint = points[i]
            local endPoint = points[(i % totalEdges) + 1]
            local extra = (i <= remainder) and 1 or 0
            local edgeSegments = segmentsPerEdge + extra

            for j = 0, edgeSegments - 1 do
                if partIndex > segments then break end
                local alpha = j / edgeSegments
                parts[partIndex].Position = startPoint:Lerp(endPoint, alpha)
                partIndex += 1
            end
        end
    end)
end


PolygonLoop()



-- SERVIÇOS
local Players = game:GetService("Players")
local UIS = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local LP = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- VARIÁVEIS
local Clone = nil

local AutoFarmConnection = nil
local OriginalCharacter = LP.Character or LP.CharacterAdded:Wait()
local HiddenParts = {}
local AutofarmMode = "player"

-- MAPA TECLAS
local keyStates = { W = false, A = false, S = false, D = false }
local isJumpingHeld = false

-- Função para esconder personagem original sem remover acessórios
local function hideCharacter(character)
    HiddenParts = {}
    for _, obj in ipairs(character:GetDescendants()) do
        if obj:IsA("BasePart") or obj:IsA("Decal") or obj:IsA("Texture") then
            HiddenParts[obj] = obj.Transparency
            obj.Transparency = 1
        end
    end
end

-- Função para mostrar personagem original restaurando transparências
local function showCharacter(character)
    for obj, origTransparency in pairs(HiddenParts) do
        if obj and obj:IsDescendantOf(character) then
            obj.Transparency = origTransparency
        end
    end
    HiddenParts = {}
end

-- Para parar o autofarm e desconectar eventos relacionados
local function stopOriginalAutoFarm()
    if AutoFarmConnection then
        AutoFarmConnection:Disconnect()
        AutoFarmConnection = nil
    end
end



-- Função chamada quando o personagem morre
local function onHumanoidDied()
    stopOriginalAutoFarm()
    if Clone then
        Clone:Destroy()
        Clone = nil
    end
    if OriginalCharacter then
        showCharacter(OriginalCharacter)
    end
    UsingClone = false
end

-- Função chamada quando o personagem (LocalPlayer) respawna
local function onCharacterAdded(char)
    OriginalCharacter = char
    UsingClone = false

    local humanoid = char:WaitForChild("Humanoid")

    -- Restaura visibilidade
    showCharacter(char)

    -- Ajusta humanoid para movimentação normal
    humanoid.WalkSpeed = movementSpeed
    humanoid.JumpPower = 50
    humanoid.AutoRotate = true

    -- Se existir clone, destruir
    if Clone then
        Clone:Destroy()
        Clone = nil
    end

    -- Configura câmera para seguir o novo personagem
    Camera.CameraSubject = humanoid

    -- Conecta evento de morte do novo personagem
    humanoid.Died:Connect(onHumanoidDied)
end

-- Inicializa conexão para respawn
LP.CharacterAdded:Connect(onCharacterAdded)

-- Se personagem já existir no momento do script rodar, conecta evento de morte
if OriginalCharacter then
    local humanoid = OriginalCharacter:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.Died:Connect(onHumanoidDied)
    end
end

-- Detecta teclas pressionadas
UIS.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if input.KeyCode == Enum.KeyCode.Space then
        isJumpingHeld = true
    end
    for _, key in pairs({"W","A","S","D"}) do
        if input.KeyCode == Enum.KeyCode[key] then
            keyStates[key] = true
        end
    end
end)

-- Detecta teclas soltas
UIS.InputEnded:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.Space then
        isJumpingHeld = false
    end
    for _, key in pairs({"W","A","S","D"}) do
        if input.KeyCode == Enum.KeyCode[key] then
            keyStates[key] = false
        end
    end
end)

-- Retorna vetor direção baseado nas teclas
local function getMoveDirection()
    local forward = (keyStates.W and not keyStates.S) and 1 or (keyStates.S and not keyStates.W) and -1 or 0
    local right = (keyStates.D and not keyStates.A) and 1 or (keyStates.A and not keyStates.D) and -1 or 0
    return Vector3.new(right, 0, forward)
end

-- Função para configurar as animações do clone
local function setupCloneAnimations(clone)
    local humanoid = clone:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end

    local animator = humanoid:FindFirstChildOfClass("Animator")
    if animator then animator:Destroy() end

    local Animations = {
        Idle = "rbxassetid://180435571",
        Walk = "rbxassetid://13772468608",
        Jump = "rbxassetid://125750702",
        Fall = "rbxassetid://180436148",
    }

    local tracks = {}
    for name, animId in pairs(Animations) do
        local anim = Instance.new("Animation")
        anim.AnimationId = animId
        tracks[name] = humanoid:LoadAnimation(anim)
    end

    local currentTrack = nil
    local inAir = false -- flag para saber se está no ar

    local function playAnimation(name)
        if currentTrack == tracks[name] then return end
        if currentTrack then currentTrack:Stop() end
        currentTrack = tracks[name]
        if currentTrack then currentTrack:Play() end
    end

    playAnimation("Idle")

    humanoid.Jumping:Connect(function()
        inAir = true
        playAnimation("Jump")
    end)

    humanoid.FreeFalling:Connect(function(active)
        inAir = active
        if active then
            playAnimation("Fall")
        else
            -- Quando parar de cair, volta para Idle se não estiver andando
            if humanoid.MoveDirection.Magnitude == 0 then
                playAnimation("Idle")
            end
        end
    end)

    game:GetService("RunService").Heartbeat:Connect(function()
        if not inAir then -- só troca walk/idle se não estiver no ar
            if humanoid.MoveDirection.Magnitude > 0 then
                playAnimation("Walk")
            else
                playAnimation("Idle")
            end
        end
    end)

    humanoid.Died:Connect(function()
        if currentTrack then currentTrack:Stop() end
    end)
end


-- Inicia o autofarm: personagem original orbita clone
local function startOriginalAutoFarm()
    stopOriginalAutoFarm()
    AutoFarmConnection = RunService.Heartbeat:Connect(function()
        if not OriginalCharacter then return end
        local root = OriginalCharacter:FindFirstChild("HumanoidRootPart")
        if not root then return end

        local center
        if AutofarmMode == "ball" then
            local ballFolder = workspace:FindFirstChild("Balls")
           if ballFolder then
    local bestBall = nil
    local highestSpeed = 0
    for _, b in ipairs(ballFolder:GetChildren()) do
        if b:IsA("BasePart") and b:FindFirstChild("zoomies") and not b.Anchored then
            local speed = b.zoomies.VectorVelocity.Magnitude
            if speed > highestSpeed then
                highestSpeed = speed
                bestBall = b
            end
        end
    end
    if bestBall then
        center = bestBall.Position
    end
end

        elseif AutofarmMode == "player" then
    if overrideAutoFarmCenter then
        center = overrideAutoFarmCenter
    elseif Clone and Clone:FindFirstChild("HumanoidRootPart") then
        center = Clone.HumanoidRootPart.Position
    end
end


        if center then
            local time = tick()
local angle = time * math.pi * 2 * orbitSpeed / 5
local verticalOffset = math.sin(time * orbitSpeedY) * 15
local yDirection = math.cos(time * orbitSpeedY)
local yOffset = yDirection > 0 and yDirection * orbitRadius or yDirection * 17

local offset = Vector3.new(
    math.cos(angle) * orbitRadius,
    yOffset,
    math.sin(angle) * orbitRadius
)


            root.CFrame = CFrame.new(center + offset)
        end
    end)
end


-- Para autofarm
local function stopOriginalAutoFarm()
    if AutoFarmConnection then
        AutoFarmConnection:Disconnect()
        AutoFarmConnection = nil
    end
end

-- Alterna entre personagem real e clone
local function toggleClone()
    if not OriginalCharacter or not OriginalCharacter:FindFirstChild("HumanoidRootPart") then return end
    local savedCameraCFrame = Camera.CFrame

    if not UsingClone then
        -- Cria clone
        -- Cria clone
Clone = OriginalCharacter:Clone()
Clone.Name = "CloneCharacter"
Clone.Parent = workspace
Clone:SetPrimaryPartCFrame(OriginalCharacter:GetPrimaryPartCFrame())
-- 2) **ACHATA** a inclinação, preservando só a rotação Y
        local hrp = Clone:WaitForChild("HumanoidRootPart")
        local pos = hrp.Position
        local look = hrp.CFrame.LookVector
        local flatLook = Vector3.new(look.X, 0, look.Z).Unit
        hrp.CFrame = CFrame.new(pos, pos + flatLook)  

        local cloneHumanoid = Clone:FindFirstChildOfClass("Humanoid")
        if cloneHumanoid then
            cloneHumanoid.WalkSpeed = movementSpeed
            cloneHumanoid.JumpPower = 50
            cloneHumanoid.AutoRotate = true
        end

        -- Configura humanoid do original para travar movimento e rotação
        local originalHumanoid = OriginalCharacter:FindFirstChildOfClass("Humanoid")
        if originalHumanoid then
            originalHumanoid.WalkSpeed = movementSpeed
            originalHumanoid.JumpPower = 50
            originalHumanoid.AutoRotate = false
        end

        startOriginalAutoFarm()
        hideCharacter(OriginalCharacter)
        setupCloneAnimations(Clone)
        copyAnimationsFromOriginalToClone(OriginalCharacter, Clone)
local cloneHRP = Clone and Clone:FindFirstChild("HumanoidRootPart")
createParticles(cloneHRP)



        Camera.CameraSubject = cloneHumanoid
        task.wait()
        Camera.CFrame = savedCameraCFrame
        UsingClone = true
        playMySound() -- toca de novo
     

   else
    -- Desativa o clone
    if Clone and Clone:FindFirstChild("HumanoidRootPart") then
        lastCloneCFrame = Clone.HumanoidRootPart.CFrame
    end

    stopOriginalAutoFarm()
    showCharacter(OriginalCharacter)

    local origHRP = OriginalCharacter and OriginalCharacter:FindFirstChild("HumanoidRootPart")
    if lastCloneCFrame and origHRP then
        origHRP.CFrame = lastCloneCFrame
    end

    local originalHumanoid = OriginalCharacter:FindFirstChildOfClass("Humanoid")
    if originalHumanoid then
        originalHumanoid.WalkSpeed = movementSpeed
        originalHumanoid.JumpPower = 50
        originalHumanoid.AutoRotate = true
    end

    Camera.CameraSubject = originalHumanoid
    Camera.CFrame = savedCameraCFrame

    if Clone then
        Clone:Destroy()
        Clone = nil
    end

    UsingClone = false
    removeParticles()
    playMySound() -- toca de novo
 

end
end

local RunService = game:GetService("RunService")

RunService.RenderStepped:Connect(function()
    if UsingClone and Clone then
        local humanoid = Clone:FindFirstChildOfClass("Humanoid")
        if humanoid then
            local camCF = workspace.CurrentCamera.CFrame
            local moveDir = getMoveDirection()
            if moveDir.Magnitude > 0 then
                local flatLook = Vector3.new(camCF.LookVector.X, 0, camCF.LookVector.Z).Unit
                local flatRight = Vector3.new(camCF.RightVector.X, 0, camCF.RightVector.Z).Unit
                local moveVector = (flatRight * moveDir.X + flatLook * moveDir.Z).Unit

                humanoid:Move(moveVector * movementSpeed, false)
            else
                humanoid:Move(Vector3.new(0,0,0), false)
            end

            if isJumpingHeld and humanoid.FloorMaterial ~= Enum.Material.Air then
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end
    end
end)



local toggleCooldown = false -- flag para impedir spam

UIS.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if input.KeyCode == toggleKey and not toggleCooldown then
        toggleCooldown = true -- ativa o bloqueio
        toggleClone()

        -- Pequeno atraso para garantir que Clone ou OriginalCharacter estejam prontos
        task.defer(function()
            local cloneHRP = Clone and Clone:FindFirstChild("HumanoidRootPart")
            local origHRP = OriginalCharacter and OriginalCharacter:FindFirstChild("HumanoidRootPart")

            if UsingClone then
                if cloneHRP then
                    CIRCLEEFFECT(cloneHRP)
                    ALTERNATINGCIRCLE(cloneHRP)
                      playInfinitySFX()
                  
                end
            else
                if origHRP then
                    CIRCLEEFFECT(origHRP)
                    ALTERNATINGCIRCLE(origHRP)
                    stopInfinitySFX()
                   
                end
            end
        end)

        -- Libera o toggle após 0.5s
        task.delay(1, function()
            toggleCooldown = false
        end)
    end
end)






local RunService   = game:GetService("RunService")
local Players      = game:GetService("Players")
local LocalPlayer  = Players.LocalPlayer

-- Estas variáveis você já deve ter no seu script:
-- UsingClone (boolean), Clone (Model), OriginalCharacter (Model)

RunService.Heartbeat:Connect(function()
    -- só roda quando o clone estiver ativo e válido
    if not UsingClone or not Clone or not Clone:FindFirstChild("HumanoidRootPart") then
        return
    end

    -- pega o HRP do original e do clone
    local origChar = OriginalCharacter
    local origHRP  = origChar and origChar:FindFirstChild("HumanoidRootPart")
    local cloneHRP = Clone:FindFirstChild("HumanoidRootPart")
    if not origHRP or not cloneHRP then
        return
    end

    -- percorre todos os Attachments do personagem original
    for _, att in ipairs(origChar:GetDescendants()) do
        if att:IsA("Attachment") then
            local parentPart = att.Parent
            if parentPart and parentPart:IsA("BasePart") then
                -- só os que estiverem a até 1 stud do original
                if (parentPart.Position - origHRP.Position).Magnitude <= 1 then
                    -- reparenta pro HRP do clone
                    att.Parent   = cloneHRP
                    -- zera o offset local (ficará na mesma posição do clone)
                    att.Position = Vector3.new(0, 0, 0)
                end
            end
        end
    end
end)




local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local savedPosition = nil
local currentTween = nil
local canFreeze = true
local cooldown = 0


local orbitConnection = nil
local orbitAngle = 0
local orbitUpdateSpeed = 4
local radius = 15

local fakeBall = nil






local speedSamples = {}
local maxSamples = 1 -- quantos valores anteriores armazenar

RunService.Heartbeat:Connect(function()
    local ballFolder = workspace:FindFirstChild("Balls")
    local bestBall = nil
    local highestSpeed = 0

    if ballFolder then
        for _, b in ipairs(ballFolder:GetChildren()) do
            if b:IsA("BasePart") and not b.Anchored then
                local speed = b.zoomies.VectorVelocity.Magnitude
                if speed > highestSpeed then
                    highestSpeed = speed
                    bestBall = b
                end
            end
        end
    end

    if bestBall then
        local speed = bestBall.zoomies.VectorVelocity.Magnitude
      
        -- Guardar amostra
        table.insert(speedSamples, speed)
        if #speedSamples > maxSamples then
            table.remove(speedSamples, 1) -- remove o mais antigo
        end

        -- Calcular média
        local sum = 0
        for _, v in ipairs(speedSamples) do
            sum = sum + v
        end
        local avgSpeed = sum / #speedSamples
-- Se a velocidade for muito alta, definir fixamente
        if avgSpeed > 15000 then
            orbitRadius = 130
            return -- pula o restante da lógica
        end
        -- Parâmetros
        local minSpeed = 800
        local maxSpeed = 10000
        local minRadius = 20
        local maxRadius = 144

        -- Clamp a velocidade média entre o mínimo e o máximo
        local clampedSpeed = math.clamp(avgSpeed, minSpeed, maxSpeed)

        -- Calcular interpolação (t entre 0 e 1)
        local t = (clampedSpeed - minSpeed) / (maxSpeed - minSpeed)

      if t > 80 then
      t = 80
      end
local newRadius = minRadius + (maxRadius - minRadius) * t

if avgSpeed > 9 or (bestBall and (bestBall.Position - Vector3.new(-283, 27.2, -69.4)).Magnitude <= 2) then
    -- Só aumenta
    if newRadius > orbitRadius then
        orbitRadius = newRadius
    end
else
    -- Aumenta ou diminui livremente se a velocidade for menor ou igual a 800
    orbitRadius = newRadius
end



    end
end)





local speedSamples2 = {}
local maxSamples2 = 1 -- quantos valores anteriores armazenar

RunService.Heartbeat:Connect(function()
    local ballFolder = workspace:FindFirstChild("Balls")
    local bestBall2 = nil
    local highestSpeed2 = 0

    if ballFolder then
        for _, b in ipairs(ballFolder:GetChildren()) do
            if b:IsA("BasePart") and not b.Anchored then
                local speed = b.zoomies.VectorVelocity.Magnitude
                if speed > highestSpeed2 then
                    highestSpeed2 = speed
                    bestBall2 = b
                end
            end
        end
    end

    if bestBall2 then
        local speed = bestBall2.zoomies.VectorVelocity.Magnitude

        -- Guardar amostra
        table.insert(speedSamples2, speed)
        if #speedSamples2 > maxSamples2 then
            table.remove(speedSamples2, 1) -- remove o mais antigo
        end

        -- Calcular média
        local sum2 = 0
        for _, v in ipairs(speedSamples2) do
            sum2 = sum2 + v
        end
        local avgSpeed2 = sum2 / #speedSamples2

        -- Parâmetros
        local minSpeed2 = 50
        local maxSpeed2 = 10000
        local minRadius2 = 10
        local maxRadius2 = 120

        -- Clamp a velocidade média entre o mínimo e o máximo
        local clampedSpeed2 = math.clamp(avgSpeed2, minSpeed2, maxSpeed2)

        -- Calcular interpolação (t entre 0 e 1)
        local t2 = (clampedSpeed2 - minSpeed2) / (maxSpeed2 - minSpeed2)

    
local newRadius2 = minRadius2 + (maxRadius2 - minRadius2) * t2

if avgSpeed2 > 9 then
    -- Só aumenta
    if newRadius2 > orbitRadius2 then
        orbitRadius2 = newRadius2
    end
else
    -- Aumenta ou diminui livremente se a velocidade for menor ou igual a 800
    orbitRadius2 = newRadius2
end



    end
end)







RunService.Heartbeat:Connect(function()
    if not UsingClone or not Clone or not Clone:FindFirstChild("HumanoidRootPart") then return end
    if not _G.PolygonLoopParts then return end

    local clonePos = Clone.HumanoidRootPart.Position
    local limit = orbitRadius + 17
    local tooClose = false

    
for _, point in ipairs(_G.PolygonLoopParts) do
    if point:IsA("BasePart") and point:IsDescendantOf(workspace) then
        local cloneXZ = Vector2.new(clonePos.X, clonePos.Z)
        local pointXZ = Vector2.new(point.Position.X, point.Position.Z)
        local horizontalDist = (cloneXZ - pointXZ).Magnitude

        if horizontalDist <= limit then
            tooClose = true
            break
        end
    end
end



    if tooClose then
        overrideAutoFarmCenter = Vector3.new(-283, 27.2, -69.4)
    else
        overrideAutoFarmCenter = nil
    end
end)


local lastAnimationTime = 0
local cooldown = 0.6

local function playAnimationOnClone()
    if os.clock() - lastAnimationTime < cooldown then
        -- Ainda em cooldown, não executa
        return
    end
    lastAnimationTime = os.clock()

    if not Clone then
        warn("Clone não existe.")
        return
    end

    local humanoid = Clone:FindFirstChildOfClass("Humanoid")
    if not humanoid then
        warn("Clone não possui Humanoid.")
        return
    end

    local animator = humanoid:FindFirstChildOfClass("Animator")
    if not animator then
        -- Se não tiver, cria
        animator = Instance.new("Animator")
        animator.Parent = humanoid
    end

    local animation = Instance.new("Animation")
    animation.AnimationId = "rbxassetid://14556917319"

    local track = animator:LoadAnimation(animation)
    track:Play()

    print("Animação tocando no clone!")
end
local ReplicatedStorage = game:GetService("ReplicatedStorage")

ReplicatedStorage.Remotes.ParrySuccess.OnClientEvent:Connect(playAnimationOnClone)




local isPRActive = false
local prLoopThread = nil
local prBall = nil

function startPR(ball)
    if not ball or not ball:IsA("BasePart") then return end
    if isPRActive then return end
    isPRActive = true
    prBall = ball

    -- Cria o attachment e emitter se não existirem
    local attachment = ball:FindFirstChild("EffectAttachment")
    if not attachment then
        attachment = Instance.new("Attachment")
        attachment.Name = "EffectAttachment"
        attachment.Parent = ball
    end

    local emitter = attachment:FindFirstChild("PurplePulse")
    if not emitter then
        emitter = Instance.new("ParticleEmitter")
        emitter.Name = "PurplePulse"
        emitter.Texture = "rbxassetid://14834478801"
        emitter.Color = ColorSequence.new(Color3.fromRGB(170, 50, 255))
        emitter.LightEmission = 999
        emitter.LightInfluence = 99
        emitter.Size = NumberSequence.new(4)
        emitter.Transparency = NumberSequence.new(0)
        emitter.Lifetime = NumberRange.new(25566)
        emitter.Rate = 25
        emitter.Speed = NumberRange.new(0)
        emitter.SpreadAngle = Vector2.new(0, 0)
        emitter.EmissionDirection = Enum.NormalId.Top
        emitter.LockedToPart = true
        emitter.ZOffset = 0
        emitter.RotSpeed = NumberRange.new(0)
        emitter.Enabled = true
        emitter.Parent = attachment
    end

    -- Loop da partícula viva
    prLoopThread = task.spawn(function()
        while isPRActive do
            emitter:Emit(1)
            task.wait(2)

            -- Remove a partícula lentamente simulando fade
            local originalRate = emitter.Rate
            emitter.Rate = 0
            for i = 1, originalRate do
                if not isPRActive then break end
                emitter:Emit(-1) -- força remover 1 (visual)
                task.wait(0.1)
            end

            emitter.Rate = originalRate
        end
    end)
end

function stopPR()
    isPRActive = false
    if prLoopThread then
        task.cancel(prLoopThread)
        prLoopThread = nil
    end

    -- Opcional: desativa o emitter ou remove completamente
    if prBall and prBall:FindFirstChild("EffectAttachment") then
        local att = prBall.EffectAttachment
        local emitter = att:FindFirstChild("PurplePulse")
        if emitter then
            emitter.Enabled = false
        end
    end
end
















local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local currentTween = nil
local savedPosition = nil
local lastTweenTime = 0
local cooldown = 0.6
local forceCooldown = false -- se true, impede congelar bola após parry

-- Detecta parry bem-sucedido
ReplicatedStorage.Remotes.ParrySuccess.OnClientEvent:Connect(function()
    forceCooldown = true
    lastTweenTime = tick()

    if currentTween then
        currentTween:Cancel()
        currentTween = nil
    end

    local ballFolder = workspace:FindFirstChild("Balls")
    local ball = ballFolder and ballFolder:FindFirstChildWhichIsA("BasePart", true)
    if ball and ball.Anchored then
        ball.Anchored = false
    end
end)
local canFreezeV = true
RunService.Heartbeat:Connect(function()

if canFreezeV then

    local ballFolder = workspace:FindFirstChild("Balls")
    local minRadius = 10
    local maxRadius = 30
    local minTween = 0.02
    local maxTween = 0.2

    local t = math.clamp((orbitRadius2 - minRadius) / (maxRadius - minRadius), 0, 1)
    local valorLol = maxTween * (1 - t) + minTween * t

    if not UsingClone or not Clone then return end

    local cloneHRP = Clone:FindFirstChild("HumanoidRootPart")
    local ball = ballFolder and ballFolder:FindFirstChildWhichIsA("BasePart", true)
    if not cloneHRP or not ball then return end

    local isTarget = ball:GetAttribute("target") == Players.LocalPlayer.Name
    local direction = cloneHRP.Position - ball.Position
    local distance = direction.Magnitude

    local Speed = ball.zoomies.VectorVelocity.Magnitude
local START_DECEL_DIST = 1

    if Speed > 499 then 
    START_DECEL_DIST = orbitRadius / 1.1
    else 
    START_DECEL_DIST = 15.1
end
    
    local STOP_DIST = 13

    -- Condição para resetar se não é alvo ou muito longe
    if not isTarget or distance > START_DECEL_DIST then
        if ball.Anchored then ball.Anchored = false end
        if currentTween then currentTween:Cancel() currentTween = nil end
        savedPosition = nil
   --   
        return
    end

    local now = tick()
    if forceCooldown and now - lastTweenTime >= cooldown then
        forceCooldown = false -- fim do cooldown forçado
        
    end

    if now - lastTweenTime < cooldown then return end

    -- Cálculo de tempo baseado na distância
    local t2 = math.clamp(1 - ((distance - STOP_DIST) / (START_DECEL_DIST - STOP_DIST)), 0, 1)
    local tweenTime = 0.1 + (valorLol - 0.1) * t2

    -- Posição alvo
    local targetCFrame
    if distance <= STOP_DIST then
        targetCFrame = ball.CFrame
    else
        local targetPos = cloneHRP.Position - direction.Unit * STOP_DIST
        targetCFrame = CFrame.new(targetPos)
    end

    -- Cria tween
    if currentTween then currentTween:Cancel() end
    ball.Anchored = true
     --startPR(ball) -- começa o loop do efeit
    currentTween = TweenService:Create(ball, TweenInfo.new(tweenTime, Enum.EasingStyle.Linear), {
        CFrame = targetCFrame
    })
    currentTween:Play()

    lastTweenTime = now




end

end)
























-- Detecta quando o personagem real morre, para destruir o clone e restaurar
if OriginalCharacter then
    local humanoid = OriginalCharacter:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.Died:Connect(function()
            stopOriginalAutoFarm()

            if Clone then
                Clone:Destroy()
                Clone = nil
            end

            UsingClone = false

            if OriginalCharacter then
                showCharacter(OriginalCharacter)
                local origHumanoid = OriginalCharacter:FindFirstChildOfClass("Humanoid")
                if origHumanoid then
                    origHumanoid.WalkSpeed = movementSpeed
                    origHumanoid.JumpPower = 50
                    origHumanoid.AutoRotate = true
                end
                Camera.CameraSubject = origHumanoid
            end
        end)
    end
end

setfpscap(999)




-- MANUAL SPAM GUI  


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

local Remotes = {}
local Parry_Key = nil

local toggleSpam = false
local spamConnection = nil

-- Função para detectar Remotes (igual no seu script)
task.spawn(function()
    for _, Value in pairs(getgc(true)) do
        if ((type(Value) == "function") and islclosure(Value)) then
            local Protos = debug.getprotos(Value)
            local Upvalues = debug.getupvalues(Value)
            local Constants = debug.getconstants(Value)
            if (Protos and Upvalues and Constants and (#Protos == 4) and (#Upvalues == 24) and (#Constants == 104)) then
                Remotes[debug.getupvalue(Value, 16)] = debug.getconstant(Value, 62)
                Parry_Key = debug.getupvalue(Value, 17)
                Remotes[debug.getupvalue(Value, 18)] = debug.getconstant(Value, 64)
                Remotes[debug.getupvalue(Value, 19)] = debug.getconstant(Value, 65)
                print("Remote found , made by the best autoparryier on the world -> VOX")
                break
            end
        end
    end
end)

local function Parry_Data()
    local ViewportSize = Camera.ViewportSize
    local MouseLocation = Vector2.new(ViewportSize.X / 2, ViewportSize.Y / 2)
    local Used = { MouseLocation.X, MouseLocation.Y }

    local Alive = Workspace.Alive:GetChildren()
    local Events = {}

    for _, v in ipairs(Alive) do
        if v.PrimaryPart then
            Events[tostring(v)] = Camera:WorldToScreenPoint(v.PrimaryPart.Position)
        end
    end

    local DirectionCF = Camera.CFrame

    return {0, DirectionCF, Events, Used}
end

local function Parry()
    if not next(Remotes) or not Parry_Key then 
        warn("❌ not found remote")
        return 
    end

    local Data = Parry_Data()

    for Remote, Args in pairs(Remotes) do
        Remote:FireServer(Args, Parry_Key, Data[1], Data[2], Data[3], Data[4])
    end
end

-- Variável para controlar a velocidade do parry (vezes por segundo)
local parrySpeed = 50 -- padrão inicial

-- Criar GUI
local manualSpamGui = Instance.new("ScreenGui")
manualSpamGui.Name = "ManualSpamUI"
manualSpamGui.Parent = game:GetService("CoreGui")
manualSpamGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
manualSpamGui.ResetOnSpawn = false

local Main = Instance.new("Frame")
Main.Name = "Main"
Main.Parent = manualSpamGui
Main.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
Main.BorderSizePixel = 0
Main.Position = UDim2.new(0.4, 0, 0.4, 0)
Main.Size = UDim2.new(0.2, 0, 0.18, 0)
Main.Active = true
Main.Draggable = true

local UICorner = Instance.new("UICorner", Main)
UICorner.CornerRadius = UDim.new(0, 12)

local title = Instance.new("TextLabel")
title.Parent = Main
title.Size = UDim2.new(1, 0, 0.25, 0)
title.BackgroundTransparency = 1
title.Text = "Manual Spam"
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.Font = Enum.Font.GothamBold
title.TextScaled = true

local speedLabel = Instance.new("TextLabel")
speedLabel.Parent = Main
speedLabel.Size = UDim2.new(0.6, 0, 0.2, 0)
speedLabel.Position = UDim2.new(0.1, 0, 0.3, 0)
speedLabel.BackgroundTransparency = 1
speedLabel.Text = "(made by vox) parrys per second:"
speedLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
speedLabel.Font = Enum.Font.Gotham
speedLabel.TextScaled = true
speedLabel.TextXAlignment = Enum.TextXAlignment.Left

local speedInput = Instance.new("TextBox")
speedInput.Parent = Main
speedInput.Size = UDim2.new(0.3, 0, 0.2, 0)
speedInput.Position = UDim2.new(0.7, 0, 0.3, 0)
speedInput.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
speedInput.TextColor3 = Color3.fromRGB(255, 255, 255)
speedInput.Font = Enum.Font.Gotham
speedInput.TextScaled = true
speedInput.ClearTextOnFocus = false
speedInput.Text = tostring(parrySpeed)
speedInput.PlaceholderText = "Ex: 50"

local spamButton = Instance.new("TextButton")
spamButton.Name = "SpamButton"
spamButton.Parent = Main
spamButton.Size = UDim2.new(0.8, 0, 0.3, 0)
spamButton.Position = UDim2.new(0.1, 0, 0.6, 0)
spamButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
spamButton.Text = "OFF"
spamButton.TextColor3 = Color3.fromRGB(255, 255, 255)
spamButton.Font = Enum.Font.GothamBold
spamButton.TextScaled = true

local UICorner2 = Instance.new("UICorner", spamButton)
UICorner2.CornerRadius = UDim.new(0, 8)

local function updateButton()
    if toggleSpam then
        spamButton.BackgroundColor3 = Color3.fromRGB(0, 200, 0)
        spamButton.Text = "ON"
    else
        spamButton.BackgroundColor3 = Color3.fromRGB(200, 0, 0)
        spamButton.Text = "OFF"
    end
end

local lastParryTime = 0

spamButton.MouseButton1Click:Connect(function()
    toggleSpam = not toggleSpam
    updateButton()

    if toggleSpam then
        lastParryTime = 0
        spamConnection = RunService.Heartbeat:Connect(function(deltaTime)
            if not toggleSpam then return end
            lastParryTime = lastParryTime + deltaTime
            local interval = 1 / parrySpeed
            if lastParryTime >= interval then
                lastParryTime = lastParryTime - interval
                pcall(Parry)
            end
        end)
    else
        if spamConnection then
            spamConnection:Disconnect()
            spamConnection = nil
        end
    end
end)

-- Atualizar parrySpeed ao digitar no textbox (quando a pessoa apertar Enter ou perder o foco)
local function tryUpdateSpeed()
    local val = tonumber(speedInput.Text)
    if val and val > 0 and val <= 1000 then -- limitar valores absurdos
        parrySpeed = val
        print("Parry speed set to: " .. parrySpeed .. " times per sec (vox on top)")
    else
        speedInput.Text = tostring(parrySpeed) -- resetar se inválido
    end
end

speedInput.FocusLost:Connect(function(enterPressed)
    if enterPressed then
        tryUpdateSpeed()
    end
end)

updateButton()
                                                                                                                                                                                               
